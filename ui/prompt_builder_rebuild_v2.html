<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interior Scene Prompt Builder Rebuild v2.3</title>
  <style>
    :root { --bg:#0f1115; --panel:#171a21; --line:#2a2f3a; --text:#e9edf5; --muted:#a4adbd; --accent:#7aa2ff; --ok:#19c37d; --bad:#ff5d6c; --off:#5a6375; }
    * { box-sizing:border-box; font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    body { margin:0; background:var(--bg); color:var(--text); }
    header { padding:14px 18px; border-bottom:1px solid var(--line); }
    h1 { margin:0; font-size:18px; }
    .meta { color:var(--muted); font-size:12px; margin-top:4px; }
    .wrap { display:grid; grid-template-columns:minmax(680px,1.5fr) minmax(420px,1fr); gap:12px; padding:12px; min-height:calc(100vh - 56px); }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; overflow:auto; }
    .control-grid { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .sec { border:1px solid var(--line); border-radius:10px; padding:10px; }
    .sec h3 { margin:0 0 8px; font-size:13px; }
    label { display:block; margin:8px 0 6px; color:var(--muted); font-size:12px; }
    button, input, textarea { width:100%; background:#12151b; color:var(--text); border:1px solid #303747; border-radius:8px; padding:8px; font-size:13px; }
    button { cursor:pointer; }
    button:hover { border-color:var(--accent); }
    .seg { display:grid; gap:6px; grid-template-columns:repeat(3,minmax(0,1fr)); }
    .seg.seg-2 { grid-template-columns:repeat(2,minmax(0,1fr)); }
    .seg.seg-4 { grid-template-columns:repeat(4,minmax(0,1fr)); }
    .seg button.active { background:#1e2d4d; border-color:#5c7ecf; }
    .seg button.off { color:var(--off); border-color:#3b4252; background:#151820; cursor:not-allowed; }
    .tiny { font-size:11px; color:var(--muted); margin-top:4px; }
    .angle-pad-wrap { border:1px solid #33405a; border-radius:10px; background:#121826; padding:8px; max-width:190px; }
    .angle-pad { position:relative; width:100%; aspect-ratio:1/1; border:1px solid #3b4b6f; border-radius:8px; background:linear-gradient(to right, transparent 49.5%, #42557f 49.5%, #42557f 50.5%, transparent 50.5%), linear-gradient(to bottom, transparent 49.5%, #42557f 49.5%, #42557f 50.5%, transparent 50.5%), #0f1522; cursor:crosshair; }
    .angle-marker { position:absolute; width:12px; height:12px; border-radius:50%; border:2px solid #dce8ff; background:#7aa2ff; transform:translate(-50%,-50%); box-shadow:0 0 0 3px rgba(122,162,255,.2); pointer-events:none; }
    .camera-row { display:grid; grid-template-columns:200px 1fr; gap:10px; }
    .btns3 { display:grid; grid-template-columns:repeat(3,minmax(0,1fr)); gap:8px; margin-top:10px; }
    pre { white-space:pre-wrap; word-break:break-word; background:#11141a; border:1px solid #2b3342; border-radius:8px; padding:10px; min-height:340px; font-size:12px; }
    .chips { display:flex; flex-wrap:wrap; gap:6px; margin-top:8px; }
    .chip { padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid #39445d; background:#151c2b; }
    .chip.ok { border-color:#1f5a43; color:#96f0c8; }
    .chip.bad { border-color:#6d2b35; color:#ffadb7; }
    .status { margin-top:8px; color:var(--muted); font-size:12px; }
    textarea { min-height:66px; resize:vertical; }
    @media (max-width: 1200px) { .wrap, .control-grid, .camera-row { grid-template-columns:1fr; } .angle-pad-wrap { max-width:100%; } }
  </style>
</head>
<body>
  <header>
    <h1>Interior Scene Prompt Builder Rebuild v2.3</h1>
    <div class="meta">Left: controls (wider) · Right: prompt generation</div>
  </header>

  <div class="wrap">
    <section class="panel">
      <div class="control-grid">
        <div class="sec">
          <h3>Space</h3>
          <label>Primary Space</label>
          <div class="seg seg-4" id="spaceSeg"></div>
          <label>In-space Placement</label>
          <div class="seg seg-2" id="placementSeg"></div>
          <div class="tiny">Disabled options stay visible to preserve layout.</div>
          <label>Scale</label>
          <div class="seg seg-4" id="scaleSeg"></div>
          <div id="scaleText" class="tiny"></div>
        </div>

        <div class="sec">
          <h3>Scene Style</h3>
          <label>Scene DNA Preset</label>
          <div class="seg seg-2" id="sceneDnaSeg"></div>
          <label>Time of Day</label>
          <div class="seg seg-3" id="timeSeg"></div>
          <label>Decor Density</label>
          <div class="seg seg-3" id="densitySeg"></div>
          <label>Distance</label>
          <div class="seg seg-3" id="distanceSeg"></div>
          <label>Lens</label>
          <div class="seg seg-3" id="lensSeg"></div>
        </div>

        <div class="sec" style="grid-column:1 / -1;">
          <h3>Camera</h3>
          <div class="camera-row">
            <div class="angle-pad-wrap">
              <div id="anglePad" class="angle-pad"><div id="angleMarker" class="angle-marker"></div></div>
              <div class="tiny" id="angleReadout">Pitch 20° · Yaw Right 30°</div>
            </div>
            <div>
              <label>Angle Presets</label>
              <div class="seg seg-3" id="anglePresetSeg"></div>
              <label>Keep-out Clause</label>
              <textarea id="keepout">clear perimeter around hero subject</textarea>
              <label>Scene Intent</label>
              <textarea id="brandMoment">composition prepared for later object compositing</textarea>
            </div>
          </div>
        </div>

        <div class="sec">
          <h3>Anchor Zone</h3>
          <div class="seg seg-2" id="anchorSeg"></div>
        </div>

        <div class="sec">
          <h3>Layout Cue</h3>
          <div class="seg seg-2" id="layoutSeg"></div>
        </div>
      </div>

      <div class="btns3">
        <button id="savePresetBtn" type="button">Save Preset</button>
        <button id="loadPresetBtn" type="button">Load Preset</button>
        <button id="resetBtn" type="button">Reset</button>
      </div>
      <div class="status" id="status"></div>
    </section>

    <section class="panel">
      <h3>Prompt</h3>
      <div class="btns3" style="margin-top:0; margin-bottom:8px;">
        <button id="generateBtn" type="button">Generate Prompt</button>
        <button id="copyPromptBtn" type="button">Copy Prompt</button>
        <button id="exportLogBtn" type="button">Export Session Log</button>
      </div>
      <pre id="promptView"></pre>
      <div class="chips" id="quickChecks"></div>
    </section>
  </div>

<script>
const OPTIONS = {
  spaces: [
    {id:'living room', label:'Living Room'},
    {id:'bedroom', label:'Bedroom'},
    {id:'dining area', label:'Dining Area'},
    {id:'kitchen', label:'Kitchen'},
    {id:'home office', label:'Home Office / Study'},
    {id:'entryway', label:'Entryway / Hallway'},
    {id:'home outdoor', label:'Home Outdoor'}
  ],
  placementsBySpace: {
    'living room': ['by the sofa','on the side table','on the media console','on the floating shelf','near the window bench','on the rug edge'],
    'bedroom': ['on the nightstand','on the dresser top','on the bedside shelf','on the foot bench','near the curtain side'],
    'dining area': ['at the table center','on the sideboard','on the wall shelf','near the dining corner'],
    'kitchen': ['on the kitchen island','on the counter corner','on the breakfast bar','on the open shelf'],
    'home office': ['on the desk corner','on the side credenza','on the bookshelf','near the reading chair'],
    'entryway': ['on the entry console','on the shoe cabinet top','on the hallway niche shelf','near the entry bench'],
    'home outdoor': ['on the patio table','on the terrace console','by the balcony railing','near the outdoor lounge chair','on the deck side table','at the garden seating edge']
  },
  allPlacements: ['by the sofa','on the side table','on the media console','on the floating shelf','near the window bench','on the rug edge','on the nightstand','on the dresser top','on the bedside shelf','on the foot bench','near the curtain side','at the table center','on the sideboard','on the wall shelf','near the dining corner','on the kitchen island','on the counter corner','on the breakfast bar','on the open shelf','on the desk corner','on the side credenza','on the bookshelf','near the reading chair','on the entry console','on the shoe cabinet top','on the hallway niche shelf','near the entry bench','on the patio table','on the terrace console','by the balcony railing','near the outdoor lounge chair','on the deck side table','at the garden seating edge'],
  times:['Daytime','Golden Hour','Evening'],
  density:['Low','Medium','High'],
  distances:['Wide shot','Medium shot','Close shot'],
  lenses:[
    {id:'wide', label:'Wide (16-28mm)', cue:'wide-angle perspective'},
    {id:'standard', label:'Standard (35-50mm)', cue:'natural perspective'},
    {id:'tele', label:'Telephoto (70-100mm)', cue:'compressed perspective'}
  ],
  anglePresets:[
    {id:'eye-threequarter', label:'Eye-level 3/4', pitch:10, yaw:30},
    {id:'elevated-threequarter', label:'Elevated 3/4', pitch:25, yaw:35},
    {id:'low-threequarter', label:'Low 3/4', pitch:-5, yaw:25},
    {id:'frontal', label:'Frontal', pitch:8, yaw:0},
    {id:'side', label:'Side', pitch:10, yaw:65},
    {id:'top-down-soft', label:'Soft Top-down', pitch:35, yaw:15}
  ],
  anchors:[
    {id:'center clear', label:'Center clear', cue:'keep central negative space for subject readability'},
    {id:'right third clear', label:'Right-third clear', cue:'maintain clear negative space in the right third'},
    {id:'left third clear', label:'Left-third clear', cue:'maintain clear negative space in the left third'},
    {id:'foreground clear', label:'Foreground clear', cue:'keep the foreground uncluttered to improve depth separation'}
  ],
  layouts:[
    {id:'symmetry', label:'Balanced symmetry', cue:'use a balanced symmetrical composition with stable verticals'},
    {id:'asymmetry', label:'Balanced asymmetry', cue:'use a balanced asymmetrical composition with intentional visual weight'},
    {id:'depth layering', label:'Depth layering', cue:'emphasize foreground, midground, and background separation'},
    {id:'open circulation', label:'Open circulation', cue:'keep circulation lines readable and spatial flow unobstructed'}
  ]
};

const state = {
  lexicon:null,
  values: {
    space:'living room',
    placement:'by the sofa',
    sceneDna:'',
    time:'Daytime',
    density:'Medium',
    distance:'Medium shot',
    lens:'wide',
    scale:1,
    pitch:20,
    yaw:30,
    anchor:'right third clear',
    layout:'asymmetry'
  },
  logs:[]
};

const $ = id => document.getElementById(id);

function stripQuote(v){ return (v || '').replace(/^"|"$/g, '').trim(); }
function parseSceneDnaYml(text){
  const out = {}; let preset = null;
  text.split('\n').forEach((line)=>{
    if (/^\s{2}[a-z_]+:$/.test(line)) { preset = line.trim().slice(0,-1); out[preset] = {}; return; }
    if (/^\s{4}[a-z_]+: /.test(line) && preset) { const idx=line.indexOf(':'); const key=line.trim().slice(0,line.trim().indexOf(':')); out[preset][key]=stripQuote(line.slice(idx+1)); }
  });
  return out;
}
function parseScaleBucketsYml(text){
  const out=[]; let item=null;
  text.split('\n').forEach((line)=>{
    if (/^\s{2}- id: /.test(line)) { item={id:line.split(':').slice(1).join(':').trim()}; out.push(item); return; }
    if (!item) return;
    if (/^\s{4}surface_prompt: /.test(line)) item.surface_prompt=stripQuote(line.split(':').slice(1).join(':'));
  });
  return out;
}

async function loadLexicons(){
  const [dnaText,scaleText] = await Promise.all([
    fetch('../lexicon/scene_dna.yml').then(r=>r.text()),
    fetch('../lexicon/scale_buckets.yml').then(r=>r.text())
  ]);
  state.lexicon = {
    sceneDna: parseSceneDnaYml(dnaText).scene_dna || parseSceneDnaYml(dnaText),
    scaleBuckets: parseScaleBucketsYml(scaleText)
  };
}

function renderButtons(rootId, items, value, onClick, labelFn=(x)=>x, keyFn=(x)=>x){
  const root = $(rootId);
  root.innerHTML = '';
  items.forEach(item=>{
    const key = keyFn(item);
    const btn = document.createElement('button');
    btn.type='button';
    btn.dataset.value = key;
    btn.textContent = labelFn(item);
    if (value === key) btn.classList.add('active');
    btn.addEventListener('click', ()=>onClick(key));
    root.appendChild(btn);
  });
}

function renderPlacementButtons(){
  const allowed = new Set(OPTIONS.placementsBySpace[state.values.space] || []);
  const root = $('placementSeg');
  root.innerHTML = '';
  OPTIONS.allPlacements.forEach(p=>{
    const btn = document.createElement('button');
    btn.type='button';
    btn.dataset.value = p;
    btn.textContent = p;
    const enabled = allowed.has(p);
    if (!enabled) {
      btn.disabled = true;
      btn.classList.add('off');
    }
    if (state.values.placement === p) btn.classList.add('active');
    btn.addEventListener('click', ()=>{
      if (!enabled) return;
      state.values.placement = p;
      renderPlacementButtons();
    });
    root.appendChild(btn);
  });

  if (!allowed.has(state.values.placement)) {
    state.values.placement = [...allowed][0] || OPTIONS.allPlacements[0];
    renderPlacementButtons();
  }
}

function renderScaleButtons(){
  const items = state.lexicon.scaleBuckets.map((b,i)=>({i, label:b.id.replaceAll('_',' ')}));
  renderButtons('scaleSeg', items, state.values.scale, (k)=>{ state.values.scale = Number(k); updateScaleText(); }, (x)=>x.label, (x)=>x.i);
}

function updateScaleText(){
  const bucket = state.lexicon.scaleBuckets[state.values.scale];
  $('scaleText').textContent = bucket ? bucket.surface_prompt : '';
}

function setPitchYaw(pitch,yaw){
  state.values.pitch = Math.max(-20, Math.min(60, Math.round(pitch)));
  state.values.yaw = Math.max(-90, Math.min(90, Math.round(yaw)));
  syncAnglePadFromState();
}

function syncAnglePadFromState(){
  const x = ((state.values.yaw + 90)/180)*100;
  const y = 100 - ((state.values.pitch + 20)/80)*100;
  $('angleMarker').style.left = `${Math.max(0,Math.min(100,x))}%`;
  $('angleMarker').style.top = `${Math.max(0,Math.min(100,y))}%`;
  const dir = state.values.yaw >= 0 ? 'Right' : 'Left';
  $('angleReadout').textContent = `Pitch ${state.values.pitch}° · Yaw ${dir} ${Math.abs(state.values.yaw)}°`;
}

function applyAnglePreset(id){
  const p = OPTIONS.anglePresets.find(x=>x.id===id);
  if (!p) return;
  setPitchYaw(p.pitch, p.yaw);
}

function cameraPromptFromAngles(){
  const p = state.values.pitch;
  const y = state.values.yaw;
  const elev = p >= 28 ? 'slightly elevated view' : p <= 0 ? 'slightly low-angle view' : 'eye-level view';
  const az = Math.abs(y) < 12 ? 'frontal composition' : Math.abs(y) < 48 ? 'three-quarter composition' : 'side-oriented composition';
  return `${elev}, ${az}`;
}

function getCurrent(){
  const dna = state.lexicon.sceneDna[state.values.sceneDna];
  const lens = OPTIONS.lenses.find(x=>x.id===state.values.lens);
  const anchor = OPTIONS.anchors.find(x=>x.id===state.values.anchor);
  const layout = OPTIONS.layouts.find(x=>x.id===state.values.layout);
  const scale = state.lexicon.scaleBuckets[state.values.scale];
  return {dna,lens,anchor,layout,scale};
}

function compilePrompt(){
  const c = getCurrent();
  const core = [
    `${state.values.space} interior scene`,
    `${state.values.time.toLowerCase()} lighting`,
    `placement: ${state.values.placement}`,
    `decor density: ${state.values.density.toLowerCase()}`,
    `camera framing: ${state.values.distance.toLowerCase()}`,
    `camera perspective: ${c.lens.cue}`,
    `camera orientation: ${cameraPromptFromAngles()}`,
    `scene palette: ${c.dna.palette}`,
    `scene materials: ${c.dna.materials}`,
    `scene lighting style: ${c.dna.lighting}`,
    `scene grading: ${c.dna.grading}`,
    `photography mood: ${c.dna.photography_vibe}`,
    `spatial guidance: ${c.anchor.cue}`,
    `layout guidance: ${c.layout.cue}`,
    `support scale: ${c.scale.surface_prompt}`,
    `clearance: ${$('keepout').value.trim()}`,
    `scene intent: ${$('brandMoment').value.trim()}`
  ];
  return core.join(', ')
    .replace(/\bproducts\b/gi,'subjects')
    .replace(/\bproduct\b/gi,'subject');
}

function renderQuickChecks(prompt){
  const checks = [
    {ok: !/\bpitch\b|\byaw\b|°/i.test(prompt), msg:'No raw degree tokens in prompt'},
    {ok: prompt.includes('camera orientation:') && prompt.includes('camera perspective:'), msg:'Model-friendly camera language'},
    {ok: prompt.includes('spatial guidance:') && prompt.includes('layout guidance:'), msg:'Anchor/Layout mapped to prompt cues'}
  ];
  const root = $('quickChecks'); root.innerHTML='';
  checks.forEach(c=>{ const d=document.createElement('div'); d.className=`chip ${c.ok?'ok':'bad'}`; d.textContent=`${c.ok?'PASS':'CHECK'} · ${c.msg}`; root.appendChild(d); });
}

function generate(){
  const prompt = compilePrompt();
  $('promptView').textContent = prompt;
  renderQuickChecks(prompt);
  state.logs.push({ts:new Date().toISOString(), space:state.values.space, placement:state.values.placement, lens:state.values.lens});
  $('status').textContent = 'Prompt generated with model-friendly camera/layout wording.';
}

function savePreset(){
  const data = {
    values: state.values,
    keepout: $('keepout').value,
    brandMoment: $('brandMoment').value
  };
  localStorage.setItem('prompt_builder_rebuild_v2_preset', JSON.stringify(data));
  $('status').textContent = 'Preset saved.';
}

function loadPreset(){
  const raw = localStorage.getItem('prompt_builder_rebuild_v2_preset');
  if (!raw) { $('status').textContent='No preset saved yet.'; return; }
  try {
    const data = JSON.parse(raw);
    state.values = { ...state.values, ...(data.values || {}) };
    $('keepout').value = data.keepout || $('keepout').value;
    $('brandMoment').value = data.brandMoment || $('brandMoment').value;
    rerenderAll();
    generate();
    $('status').textContent = 'Preset loaded.';
  } catch {
    $('status').textContent = 'Preset data is invalid.';
  }
}

function resetForm(){
  state.values = { space:'living room', placement:'by the sofa', sceneDna:Object.keys(state.lexicon.sceneDna)[0], time:'Daytime', density:'Medium', distance:'Medium shot', lens:'wide', scale:1, pitch:20, yaw:30, anchor:'right third clear', layout:'asymmetry' };
  $('keepout').value = 'clear perimeter around hero subject';
  $('brandMoment').value = 'composition prepared for later object compositing';
  rerenderAll();
  $('promptView').textContent='';
  $('quickChecks').innerHTML='';
  $('status').textContent='Form reset complete.';
}

function exportLog(){
  const lines = ['# Session Log','',...state.logs.map((x,i)=>`- ${i+1}. ${x.ts} | space=${x.space} | placement=${x.placement} | lens=${x.lens}`)];
  const blob = new Blob([lines.join('\n')], {type:'text/markdown'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download='session_log.md'; a.click(); URL.revokeObjectURL(a.href);
  $('status').textContent='Session log exported.';
}

function copyPrompt(){
  const t = $('promptView').textContent || '';
  if (!t) { $('status').textContent='No prompt to copy yet.'; return; }
  navigator.clipboard.writeText(t).then(()=>$('status').textContent='Prompt copied to clipboard.').catch(()=>$('status').textContent='Clipboard copy failed.');
}

function rerenderAll(){
  renderButtons('spaceSeg', OPTIONS.spaces, state.values.space, (k)=>{ state.values.space = k; rerenderAll(); }, x=>x.label, x=>x.id);
  renderPlacementButtons();
  renderButtons('sceneDnaSeg', Object.keys(state.lexicon.sceneDna), state.values.sceneDna, (k)=>{ state.values.sceneDna = k; rerenderSceneDna(); });
  renderButtons('timeSeg', OPTIONS.times, state.values.time, (k)=>{ state.values.time=k; rerenderTime(); });
  renderButtons('densitySeg', OPTIONS.density, state.values.density, (k)=>{ state.values.density=k; rerenderDensity(); });
  renderButtons('distanceSeg', OPTIONS.distances, state.values.distance, (k)=>{ state.values.distance=k; rerenderDistance(); });
  renderButtons('lensSeg', OPTIONS.lenses, state.values.lens, (k)=>{ state.values.lens=k; rerenderLens(); }, x=>x.label, x=>x.id);
  renderScaleButtons();
  renderButtons('anchorSeg', OPTIONS.anchors, state.values.anchor, (k)=>{ state.values.anchor=k; rerenderAnchor(); }, x=>x.label, x=>x.id);
  renderButtons('layoutSeg', OPTIONS.layouts, state.values.layout, (k)=>{ state.values.layout=k; rerenderLayout(); }, x=>x.label, x=>x.id);
  renderButtons('anglePresetSeg', OPTIONS.anglePresets, null, (k)=>{ applyAnglePreset(k); }, x=>x.label, x=>x.id);
  syncAnglePadFromState();
}

function rerenderSceneDna(){ renderButtons('sceneDnaSeg', Object.keys(state.lexicon.sceneDna), state.values.sceneDna, (k)=>{ state.values.sceneDna = k; rerenderSceneDna(); }); }
function rerenderTime(){ renderButtons('timeSeg', OPTIONS.times, state.values.time, (k)=>{ state.values.time=k; rerenderTime(); }); }
function rerenderDensity(){ renderButtons('densitySeg', OPTIONS.density, state.values.density, (k)=>{ state.values.density=k; rerenderDensity(); }); }
function rerenderDistance(){ renderButtons('distanceSeg', OPTIONS.distances, state.values.distance, (k)=>{ state.values.distance=k; rerenderDistance(); }); }
function rerenderLens(){ renderButtons('lensSeg', OPTIONS.lenses, state.values.lens, (k)=>{ state.values.lens=k; rerenderLens(); }, x=>x.label, x=>x.id); }
function rerenderAnchor(){ renderButtons('anchorSeg', OPTIONS.anchors, state.values.anchor, (k)=>{ state.values.anchor=k; rerenderAnchor(); }, x=>x.label, x=>x.id); }
function rerenderLayout(){ renderButtons('layoutSeg', OPTIONS.layouts, state.values.layout, (k)=>{ state.values.layout=k; rerenderLayout(); }, x=>x.label, x=>x.id); }

function bind(){
  $('generateBtn').addEventListener('click', generate);
  $('copyPromptBtn').addEventListener('click', copyPrompt);
  $('exportLogBtn').addEventListener('click', exportLog);
  $('savePresetBtn').addEventListener('click', savePreset);
  $('loadPresetBtn').addEventListener('click', loadPreset);
  $('resetBtn').addEventListener('click', resetForm);

  let dragging = false;
  const pad = $('anglePad');
  pad.addEventListener('pointerdown', (e)=>{ dragging=true; setFromPad(e); pad.setPointerCapture(e.pointerId); });
  pad.addEventListener('pointermove', (e)=>{ if (!dragging) return; setFromPad(e); });
  pad.addEventListener('pointerup', ()=>{ dragging=false; });
  function setFromPad(e){
    const r = pad.getBoundingClientRect();
    const nx = Math.max(0, Math.min(1, (e.clientX-r.left)/r.width));
    const ny = Math.max(0, Math.min(1, (e.clientY-r.top)/r.height));
    setPitchYaw(((1-ny)*80)-20, (nx*180)-90);
  }
}

(async function init(){
  await loadLexicons();
  state.values.sceneDna = Object.keys(state.lexicon.sceneDna)[0];
  bind();
  rerenderAll();
  updateScaleText();
})();
</script>
</body>
</html>
